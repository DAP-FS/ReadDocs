=============
Core Concepts
=============

What is a Regular Expression?
=============================

A **regular expression** (regex) is a sequence of characters that defines a search pattern for strings. In Theory of Computation, regular expressions formally describe **regular languages** - the simplest class in the Chomsky hierarchy [web:26].

Formal Definition
=================

Let :math:`\Sigma` be a finite alphabet. A regular expression over :math:`\Sigma` is defined recursively:

**Base Cases:**
- :math:`\emptyset` (empty set) is a regular expression
- :math:`\epsilon` (empty string) is a regular expression  
- For each :math:`a \in \Sigma`, :math:`a` is a regular expression

**Recursive Cases:**
If :math:`r` and :math:`s` are regular expressions, then:
- :math:`(r \cup s)` or :math:`(r + s)` (union/alternation)
- :math:`(r \cdot s)` or :math:`rs` (concatenation)
- :math:`r^*` (Kleene star/closure)

are also regular expressions.

Language of a Regular Expression
=================================

Each regular expression :math:`r` defines a language :math:`L(r)`:

- :math:`L(\emptyset) = \emptyset`
- :math:`L(\epsilon) = \{\epsilon\}`
- :math:`L(a) = \{a\}` for :math:`a \in \Sigma`
- :math:`L(r + s) = L(r) \cup L(s)`
- :math:`L(rs) = L(r) \cdot L(s) = \{xy : x \in L(r), y \in L(s)\}`
- :math:`L(r^*) = (L(r))^* = \bigcup_{i=0}^{\infty} (L(r))^i`

Common Notation
===============

.. list-table:: Regular Expression Operators
   :header-rows: 1
   :widths: 20 30 50

   * - Symbol
     - Name
     - Meaning
   * - :math:`+` or :math:`\cup`
     - Union/Alternation
     - Either pattern A or pattern B
   * - :math:`\cdot` or concatenation
     - Concatenation
     - Pattern A followed by pattern B
   * - :math:`*`
     - Kleene Star
     - Zero or more repetitions
   * - :math:`()` 
     - Grouping
     - Override operator precedence

Operator Precedence
===================

From highest to lowest precedence:

1. **Kleene star** (:math:`*`)
2. **Concatenation** (no symbol)
3. **Union** (:math:`+`)

Example: :math:`ab^* + c` means :math:`(a(b^*)) + c`, not :math:`(ab)^* + c`

Connection to Finite Automata
==============================

**Fundamental Theorem**: A language is regular if and only if it can be:
- Recognized by a finite automaton (DFA/NFA)
- Generated by a regular grammar
- Described by a regular expression

This equivalence allows us to convert between representations:

- **Regex → NFA**: Thompson's construction
- **NFA → Regex**: State elimination method  
- **DFA → Regex**: State elimination or algebraic method

Regular vs Non-Regular Languages
================================

**Regular Languages** (expressible by regex):
- Strings over :math:`\{0,1\}` with even number of 1s
- All strings ending with "abc"
- Strings with no consecutive identical characters

**Non-Regular Languages** (not expressible by regex):
- :math:`\{0^n1^n : n \geq 0\}` (equal 0s and 1s)
- :math:`\{ww : w \in \{0,1\}^*\}` (repeated strings)
- Palindromes over alphabets with 3+ symbols

.. note::
   Use the **Pumping Lemma** to prove a language is not regular. If a language violates the pumping lemma conditions, it cannot be described by any regular expression.

Next Steps
==========

Now that you understand the theoretical foundation, explore concrete :doc:`examples` to see regular expressions in action.

