#########################################
A Learner's Guide to Regular Expressions
#########################################

Welcome to the world of Regular Expressions (RE) in the Theory of Computation (TOC)! This guide is designed to be your friendly handbook, breaking down complex ideas into simple, understandable pieces.

.. raw:: html

   <br>

.. admonition:: Concept
   :class: admonition-concept

   **What is a Regular Expression?**

   A Regular Expression is a sequence of characters that specifies a search pattern. In TOC, it's a formal way to describe a **Regular Language**â€”a set of strings that can be recognized by a Finite Automaton. Think of it as an algebraic formula for defining patterns in text.

**********************
1. The Core Concepts
**********************

Before we build complex expressions, let's understand the building blocks.

Alphabet (:math:`\Sigma`)
   A finite, non-empty set of symbols. For example, :math:`\Sigma = \{a, b\}` or :math:`\Sigma = \{0, 1\}`.

Empty String (:math:`\epsilon`)
   A string with zero characters. It's a valid string in many languages.

Empty Set (:math:`\emptyset`)
   Represents a language with no strings at all. It is different from the language containing only the empty string, :math:`\{\epsilon\}`.

Operators
   Regular Expressions use three primary operators to combine symbols:

   1.  **Union (+)**: Represents an "OR" condition. :math:`a+b` means either 'a' or 'b'.
   2.  **Concatenation (.)**: Joins characters or expressions sequentially. :math:`a \cdot b` (or simply :math:`ab`) means 'a' followed by 'b'.
   3.  **Kleene Star (*)**: Represents "zero or more" occurrences of the preceding character or group. :math:`a^*` means :math:`\{\epsilon, a, aa, aaa, ...\}`.

.. warning::
   :class: warning

   Don't confuse the empty string :math:`\epsilon` with the empty set :math:`\emptyset`. :math:`\epsilon` is a string, whereas :math:`\emptyset` represents a language with no strings.

********************
2. Worked Examples
********************

Let's see these concepts in action!

.. admonition:: Example 1: Language of strings ending with 'ab'
   :class: admonition-example

   **Regular Expression:** :math:`(a+b)^*ab`

   **Intuitive Explanation:**
   - :math:`(a+b)^*`: This part means "any combination of 'a's and 'b's, of any length (including zero)." This allows the string to start with anything.
   - :math:`ab`: This part forces the string to end with the exact sequence 'ab'.

   **Sample Strings:** :math:`ab`, :math:`aab`, :math:`bab`, :math:`aaaaab`, :math:`bbabab`

   **Visual Diagram (NFA):**

   .. tikz::
      [shorten >=1pt, node distance=2.5cm, on grid, auto]
      \node[state, initial] (q0) {$q_0$};
      \node[state] (q1) [right=of q0] {$q_1$};
      \node[state, accepting, fill=finalstatecolor!20] (q2) [right=of q1] {$q_2$};
      \path[->]
        (q0) edge [loop above] node {a, b} ()
        (q0) edge node {a} (q1)
        (q1) edge node {b} (q2);
   
   *Caption: This NFA accepts any string that ends in 'ab'. It stays in q0 for any character, moves to q1 on 'a', and finally to the accepting state q2 on 'b'.*

***********************************
3. Complete Pattern Collection
***********************************

Basic Patterns
===============

.. admonition:: Pattern 1: Simple Concatenation
   :class: admonition-example

   **Regular Expression:** :math:`ab`

   **Language:** Exactly the string "ab"

   .. tikz::
      [shorten >=1pt, node distance=2cm, on grid, auto]
      \node[state, initial] (q0) {$q_0$};
      \node[state] (q1) [right=of q0] {$q_1$};
      \node[state, accepting, fill=finalstatecolor!20] (q2) [right=of q1] {$q_2$};
      \path[->]
        (q0) edge node {a} (q1)
        (q1) edge node {b} (q2);

.. admonition:: Pattern 2: Star with Concatenation
   :class: admonition-example

   **Regular Expression:** :math:`ab^*c`

   **Language:** Strings starting with 'a', followed by zero or more 'b's, ending with 'c'

   .. tikz::
      [shorten >=1pt, node distance=2cm, on grid, auto]
      \node[state, initial] (q0) {$q_0$};
      \node[state] (q1) [right=of q0] {$q_1$};
      \node[state, accepting, fill=finalstatecolor!20] (q2) [right=of q1] {$q_2$};
      \path[->]
        (q0) edge node {a} (q1)
        (q1) edge [loop above] node {b} ()
        (q1) edge node {c} (q2);

.. admonition:: Pattern 3: Group Repetition
   :class: admonition-example

   **Regular Expression:** :math:`(ab)^*`

   **Language:** Zero or more repetitions of "ab"

   .. tikz::
      [shorten >=1pt, node distance=2cm, on grid, auto]
      \node[state, initial, accepting, fill=finalstatecolor!20] (q0) {$q_0$};
      \node[state] (q1) [right=of q0] {$q_1$};
      \path[->]
        (q0) edge [bend left] node {a} (q1)
        (q1) edge [bend left] node {b} (q0);

.. admonition:: Pattern 4: Prefix with Group Repetition
   :class: admonition-example

   **Regular Expression:** :math:`a(ba)^*`

   **Language:** Starts with 'a', then zero or more repetitions of "ba"

   .. tikz::
      [shorten >=1pt, node distance=2cm, on grid, auto]
      \node[state, initial] (q0) {$q_0$};
      \node[state, accepting, fill=finalstatecolor!20] (q1) [right=of q0] {$q_1$};
      \node[state] (q2) [right=of q1] {$q_2$};
      \path[->]
        (q0) edge node {a} (q1)
        (q1) edge [bend left] node {b} (q2)
        (q2) edge [bend left] node {a} (q1);

Complex Patterns
================

.. admonition:: Pattern 5: Union with Star
   :class: admonition-example

   **Regular Expression:** :math:`(a + bc)^*`

   **Language:** Zero or more repetitions of either 'a' or "bc"

   .. tikz::
      [shorten >=1pt, node distance=2cm, on grid, auto]
      \node[state, initial, accepting, fill=finalstatecolor!20] (q0) {$q_0$};
      \node[state] (q1) [above right=of q0] {$q_1$};
      \node[state] (q2) [below right=of q0] {$q_2$};
      \path[->]
        (q0) edge [loop left] node {a} ()
        (q0) edge node {b} (q1)
        (q1) edge node {c} (q0);

.. admonition:: Pattern 6: Prefix with Union Loop
   :class: admonition-example

   **Regular Expression:** :math:`a(b + a)^*`

   **Language:** Starts with 'a', then zero or more of either 'a' or 'b'

   .. tikz::
      [shorten >=1pt, node distance=2cm, on grid, auto]
      \node[state, initial] (q0) {$q_0$};
      \node[state, accepting, fill=finalstatecolor!20] (q1) [right=of q0] {$q_1$};
      \path[->]
        (q0) edge node {a} (q1)
        (q1) edge [loop above] node {a, b} ();

.. admonition:: Pattern 7: Complex Nested Expression
   :class: admonition-example

   **Regular Expression:** :math:`a^*b(c + da^*b)^*`

   **Language:** Zero or more 'a's, then 'b', then zero or more of either 'c' or "d followed by zero or more 'a's then 'b'"

   .. tikz::
      [shorten >=1pt, node distance=1.8cm, on grid, auto]
      \node[state, initial, accepting, fill=finalstatecolor!20] (q0) {$q_0$};
      \node[state, accepting, fill=finalstatecolor!20] (q1) [right=of q0] {$q_1$};
      \node[state] (q2) [above right=of q1] {$q_2$};
      \node[state] (q3) [below right=of q1] {$q_3$};
      \node[state] (q4) [right=of q3] {$q_4$};
      \path[->]
        (q0) edge [loop above] node {a} ()
        (q0) edge node {b} (q1)
        (q1) edge node {c} (q1)
        (q1) edge node {d} (q2)
        (q2) edge [loop above] node {a} ()
        (q2) edge node {b} (q1);

.. admonition:: Pattern 8: Union with Kleene Closure
   :class: admonition-example

   **Regular Expression:** :math:`(a + bc^*d)^*`

   **Language:** Zero or more repetitions of either 'a' or "b followed by zero or more 'c's then 'd'"

   .. tikz::
      [shorten >=1pt, node distance=1.8cm, on grid, auto]
      \node[state, initial, accepting, fill=finalstatecolor!20] (q0) {$q_0$};
      \node[state] (q1) [above right=of q0] {$q_1$};
      \node[state] (q2) [right=of q1] {$q_2$};
      \node[state] (q3) [below right=of q1] {$q_3$};
      \path[->]
        (q0) edge [loop left] node {a} ()
        (q0) edge node {b} (q1)
        (q1) edge [loop above] node {c} ()
        (q1) edge node {d} (q0);

************************************
4. Automata Pattern Recognition
************************************

Study these automata and identify their corresponding regular expressions:

.. admonition:: Practice 1: Three-State Loop Pattern
   :class: admonition-exercise

   .. tikz::
      [shorten >=1pt, node distance=2cm, on grid, auto]
      \node[state, initial] (q0) {$q_0$};
      \node[state] (q1) [right=of q0] {$q_1$};
      \node[state, accepting, fill=finalstatecolor!20] (q2) [right=of q1] {$q_2$};
      \path[->]
        (q0) edge [loop above] node {a, b} ()
        (q0) edge node {a} (q1)
        (q1) edge node {b} (q2)
        (q2) edge [loop above] node {a, b} ();

   **Challenge:** What language does this automaton accept?

.. admonition:: Practice 2: Epsilon-NFA with Branches
   :class: admonition-exercise

   .. tikz::
      [shorten >=1pt, node distance=2cm, on grid, auto]
      \node[state, initial] (q0) {$q_0$};
      \node[state] (q1) [above right=of q0] {$q_1$};
      \node[state] (q2) [below right=of q0] {$q_2$};
      \node[state, accepting, fill=finalstatecolor!20] (q3) [below right=of q1] {$q_3$};
      \path[->]
        (q0) edge node {$\epsilon$} (q1)
        (q0) edge node {$\epsilon$} (q2)
        (q1) edge node {a} (q3)
        (q2) edge node {b} (q3)
        (q1) edge [loop above] node {a} ()
        (q2) edge [loop below] node {b} ();

.. admonition:: Practice 3: Sequential Pattern
   :class: admonition-exercise

   .. tikz::
      [shorten >=1pt, node distance=2cm, on grid, auto]
      \node[state, initial] (q0) {$q_0$};
      \node[state] (q1) [right=of q0] {$q_1$};
      \node[state] (q2) [right=of q1] {$q_2$};
      \node[state, accepting, fill=finalstatecolor!20] (q3) [right=of q2] {$q_3$};
      \path[->]
        (q0) edge node {a} (q1)
        (q1) edge node {b} (q2)
        (q2) edge node {c} (q3);

.. admonition:: Practice 4: Alternative Paths
   :class: admonition-exercise

   .. tikz::
      [shorten >=1pt, node distance=2cm, on grid, auto]
      \node[state, initial] (q0) {$q_0$};
      \node[state] (q1) [above right=of q0] {$q_1$};
      \node[state, accepting, fill=finalstatecolor!20] (q2) [below right=of q1] {$q_2$};
      \path[->]
        (q0) edge node {a} (q1)
        (q1) edge node {b} (q2)
        (q0) edge [bend right] node {b} (q2);

.. admonition:: Practice 5: Epsilon Transition Pattern
   :class: admonition-exercise

   .. tikz::
      [shorten >=1pt, node distance=2cm, on grid, auto]
      \node[state, initial, accepting, fill=finalstatecolor!20] (q0) {$q_0$};
      \node[state] (q1) [right=of q0] {$q_1$};
      \node[state] (q2) [right=of q1] {$q_2$};
      \node[state, accepting, fill=finalstatecolor!20] (q3) [right=of q2] {$q_3$};
      \path[->]
        (q0) edge node {$\epsilon$} (q1)
        (q1) edge node {a} (q2)
        (q2) edge node {b, c} (q3)
        (q3) edge [bend right=60] node {$\epsilon$} (q0);

   **Note:** This represents :math:`(a(b+c))^*`

.. admonition:: Practice 6: Parallel Paths NFA
   :class: admonition-exercise

   .. tikz::
      [shorten >=1pt, node distance=2cm, on grid, auto]
      \node[state, initial] (q0) {$q_0$};
      \node[state] (q1) [above right=of q0] {$q_1$};
      \node[state] (q2) [below right=of q0] {$q_2$};
      \node[state, accepting, fill=finalstatecolor!20] (q3) [below right=of q1] {$q_3$};
      \path[->]
        (q0) edge node {a} (q1)
        (q1) edge node {b} (q3)
        (q1) edge node {a} (q2)
        (q2) edge node {b} (q3);

.. admonition:: Practice 7: Self-Loop with Transition
   :class: admonition-exercise

   .. tikz::
      [shorten >=1pt, node distance=2cm, on grid, auto]
      \node[state, initial] (q0) {$q_0$};
      \node[state] (q1) [right=of q0] {$q_1$};
      \node[state, accepting, fill=finalstatecolor!20] (q2) [right=of q1] {$q_2$};
      \path[->]
        (q0) edge [loop above] node {a, b} ()
        (q0) edge node {a} (q1)
        (q1) edge node {b} (q2);

.. admonition:: Practice 8: Two-State Loop Machine
   :class: admonition-exercise

   .. tikz::
      [shorten >=1pt, node distance=2.5cm, on grid, auto]
      \node[state, initial] (q0) {$q_0$};
      \node[state, accepting, fill=finalstatecolor!20] (q1) [right=of q0] {$q_1$};
      \path[->]
        (q0) edge [loop above] node {a, b} ()
        (q0) edge [bend left] node {a} (q1)
        (q1) edge [bend left] node {b} (q0);

************************
5. Interactive Exercises
************************

Time to test your knowledge! Try to solve these on your own before peeking at the solution.

.. admonition:: Exercise 1 (Basic)
   :class: admonition-exercise

   Write a Regular Expression for the language of all strings over :math:`\Sigma = \{a, b\}` that start with 'a' and end with 'b'.

   **Hint:** Think about what can come in between the first 'a' and the last 'b'. It can be anything!

.. admonition:: Solution
   :class: admonition-solution

   **Regular Expression:** :math:`a(a+b)^*b`

   **Explanation:**
   - The first **a** ensures the string starts with 'a'.
   - The middle **:math:`(a+b)^*`** allows for any sequence of 'a's and 'b's (including none).
   - The final **b** ensures the string ends with 'b'.
   - **Sample Strings**: :math:`ab`, :math:`aab`, :math:`abb`, :math:`ababab`

***************************************
8. Finite Automata to Regular Expression
***************************************

Converting finite automata to regular expressions is a fundamental skill in Theory of Computation. Let's master this through systematic examples and proven techniques.

.. admonition:: Conversion Methods
   :class: admonition-concept

   **Two Main Approaches:**
   
   1. **State Elimination Method**: Remove states one by one while preserving the language
   2. **Arden's Theorem**: Set up and solve equations for each state

State Elimination Examples
==========================

.. admonition:: Problem 1: Simple Two-State DFA
   :class: admonition-exercise

   **Given DFA:**
   
   .. tikz::
      [shorten >=1pt, node distance=2.5cm, on grid, auto]
      \node[state, initial] (A) {$A$};
      \node[state, accepting, fill=finalstatecolor!20] (B) [right=of A] {$B$};
      \path[->]
        (A) edge [loop above] node {a} ()
        (A) edge node {b} (B)
        (B) edge [loop above] node {b} ();

   **Step-by-Step Solution:**
   
   1. **Identify paths**: A can loop on 'a', transition to B on 'b', and B loops on 'b'
   2. **Direct path**: From start A to final B requires: any number of 'a's, then 'b', then any number of 'b's
   3. **Regular Expression**: :math:`a^*bb^* = a^*b^+`

.. admonition:: Problem 2: Three-State DFA with Multiple Transitions
   :class: admonition-exercise

   **Given DFA:**
   
   .. tikz::
      [shorten >=1pt, node distance=2cm, on grid, auto]
      \node[state, initial] (A) {$A$};
      \node[state] (B) [above right=of A] {$B$};
      \node[state, accepting, fill=finalstatecolor!20] (C) [below right=of B] {$C$};
      \path[->]
        (A) edge node {a} (B)
        (A) edge [bend right] node {b} (C)
        (B) edge node {b} (C)
        (B) edge [loop above] node {a} ()
        (C) edge [loop below] node {a,b} ();

   **Step-by-Step Solution:**
   
   1. **Path Analysis**:
      - Direct path Aâ†’C: 'b' then any string
      - Indirect path Aâ†’Bâ†’C: 'a', any number of 'a's, 'b', then any string
   
   2. **Eliminate intermediate state B**:
      - Effect of Aâ†’Bâ†’C: :math:`aa^*b`
      - Combined with direct path: :math:`b + aa^*b = (b + aa^*b)`
   
   3. **Final state C accepts anything**: :math:`(a+b)^*`
   
   4. **Complete Regular Expression**: :math:`(b + a^+b)(a+b)^*`

.. admonition:: Problem 3: Self-Loop Elimination
   :class: admonition-exercise

   **Given DFA:**
   
   .. tikz::
      [shorten >=1pt, node distance=2.5cm, on grid, auto]
      \node[state, initial] (A) {$A$};
      \node[state] (B) [right=of A] {$B$};
      \node[state, accepting, fill=finalstatecolor!20] (C) [right=of B] {$C$};
      \path[->]
        (A) edge [loop above] node {a} ()
        (A) edge node {b} (B)
        (B) edge [loop above] node {a} ()
        (B) edge node {b} (C)
        (C) edge [loop above] node {a,b} ();

   **Solution Process:**
   
   1. **Handle self-loops first**: A has :math:`a^*`, B has :math:`a^*`, C has :math:`(a+b)^*`
   2. **Path construction**: Aâ†’Bâ†’C becomes :math:`a^*ba^*b(a+b)^*`
   3. **Simplify**: Since A can also loop, final RE = :math:`a^*ba^*b(a+b)^*`

Arden's Theorem Method
======================

.. admonition:: Arden's Theorem
   :class: admonition-concept

   **If X = AX + B and A does not contain Îµ, then X = A*B**
   
   This theorem helps solve equations systematically when converting FA to RE.

.. admonition:: Problem 4: Using Arden's Theorem
   :class: admonition-exercise

   **Given DFA:**
   
   .. tikz::
      [shorten >=1pt, node distance=2cm, on grid, auto]
      \node[state, initial] (q0) {$q_0$};
      \node[state] (q1) [right=of q0] {$q_1$};
      \node[state, accepting, fill=finalstatecolor!20] (q2) [right=of q1] {$q_2$};
      \path[->]
        (q0) edge [loop above] node {a} ()
        (q0) edge node {b} (q1)
        (q1) edge node {a} (q2)
        (q1) edge [bend left] node {b} (q0)
        (q2) edge [loop above] node {a,b} ();

   **Setting up equations:**
   
   - :math:`q_0 = \epsilon + q_0 \cdot a + q_1 \cdot b`  ... (1)
   - :math:`q_1 = q_0 \cdot b`  ... (2)  
   - :math:`q_2 = q_1 \cdot a + q_2 \cdot (a+b)`  ... (3)

   **Solving step by step:**
   
   1. From equation (3): :math:`q_2 = q_1 \cdot a \cdot (a+b)^*`
   2. From equation (2): :math:`q_1 = q_0 \cdot b`
   3. Substitute (2) into (1): :math:`q_0 = \epsilon + q_0 \cdot a + q_0 \cdot b \cdot b`
   4. Simplify: :math:`q_0 = \epsilon + q_0(a + b^2)`
   5. Apply Arden's: :math:`q_0 = (a + b^2)^*`
   6. Find :math:`q_1`: :math:`q_1 = (a + b^2)^* \cdot b`
   7. Find :math:`q_2`: :math:`q_2 = (a + b^2)^* \cdot b \cdot a \cdot (a+b)^*`

   **Final RE**: :math:`(a + b^2)^*ba(a+b)^*`

Complex Examples
================

.. admonition:: Problem 5: Multiple Final States
   :class: admonition-exercise

   **Given DFA with two final states:**
   
   .. tikz::
      [shorten >=1pt, node distance=2cm, on grid, auto]
      \node[state, initial, accepting, fill=finalstatecolor!20] (A) {$A$};
      \node[state] (B) [right=of A] {$B$};
      \node[state, accepting, fill=finalstatecolor!20] (C) [right=of B] {$C$};
      \node[state] (D) [below=of B] {$D$};
      \path[->]
        (A) edge node {a} (B)
        (A) edge [bend right] node {b} (D)
        (B) edge node {a} (C)
        (B) edge node {b} (D)
        (D) edge [bend right] node {a} (A)
        (D) edge [loop below] node {b} ()
        (C) edge [loop above] node {a,b} ();

   **Solution Strategy:**
   
   Since there are multiple final states (A and C), we need to find expressions for reaching each:
   
   1. **RE for state A**: :math:`\epsilon + Db^*a` (including initial acceptance)
   2. **RE for state C**: Paths ending at C
   3. **Combine with union**: Final RE = RE(A) + RE(C)

   **Working through equations:**
   - A = Îµ + DÂ·b*Â·a
   - C = BÂ·aÂ·(a+b)*  
   - B = AÂ·a + DÂ·b*Â·aÂ·a
   - D = AÂ·b + BÂ·b + DÂ·b

   **Final Result**: :math:`\epsilon + (complex\ expression\ for\ paths\ to\ A\ and\ C)`

.. admonition:: Problem 6: Epsilon Transitions
   :class: admonition-exercise

   **Strategy for Îµ-NFA to RE:**
   
   1. **Remove Îµ-transitions first** by computing Îµ-closures
   2. **Convert to equivalent DFA** if needed
   3. **Apply standard conversion methods**
   
   **Key insight**: Îµ-transitions create additional paths that must be accounted for in the final regular expression.

Practice Problems
=================

.. admonition:: Exercise Set: Convert these DFAs to Regular Expressions
   :class: admonition-exercise

   **Problem A**: Two-state machine with cross-transitions
   
   .. tikz::
      [shorten >=1pt, node distance=2.5cm, on grid, auto]
      \node[state, initial] (q0) {$q_0$};
      \node[state, accepting, fill=finalstatecolor!20] (q1) [right=of q0] {$q_1$};
      \path[->]
        (q0) edge [bend left] node {a} (q1)
        (q1) edge [bend left] node {a} (q0)
        (q0) edge [loop above] node {b} ()
        (q1) edge [loop above] node {b} ();

   **Problem B**: Linear three-state chain
   
   .. tikz::
      [shorten >=1pt, node distance=2cm, on grid, auto]
      \node[state, initial] (p) {$p$};
      \node[state] (q) [right=of p] {$q$};
      \node[state, accepting, fill=finalstatecolor!20] (r) [right=of q] {$r$};
      \path[->]
        (p) edge node {a} (q)
        (q) edge node {b} (r)
        (p) edge [loop above] node {a,b} ()
        (r) edge [loop above] node {a,b} ();

.. admonition:: Solutions
   :class: admonition-solution

   **Problem A Solution**: :math:`b^*(ab^*ab^*)^*` 
   
   **Reasoning**: Start in qâ‚€, stay with b's, then alternate between states with 'a', staying in each state with b's.
   
   **Problem B Solution**: :math:`(a+b)^*ab(a+b)^*`
   
   **Reasoning**: Any string on p, then required 'ab' to reach r, then any string on r.

Key Strategies Summary
=====================

.. list-table:: Conversion Strategy Guide
   :header-rows: 1
   :widths: 30 70

   * - **Method**
     - **When to Use**
   * - State Elimination
     - Simple DFAs with few states, clear path structure
   * - Arden's Theorem  
     - Complex DFAs, multiple loops, systematic approach needed
   * - Direct Construction
     - Very simple machines (2-3 states max)
   * - Hybrid Approach
     - Combine methods: eliminate some states, then use equations

.. note:: ðŸ’¡ Pro Tips
   :class: note

   **Common Mistakes to Avoid:**
   
   1. **Forgetting self-loops**: Always check for and include state self-loops
   2. **Missing Îµ in initial states**: If start state is final, include Îµ in the RE
   3. **Incorrect state elimination order**: Eliminate non-final, non-initial states first
   4. **Union vs. concatenation confusion**: Parallel paths = union, sequential paths = concatenation

   **Verification Method**: Construct a few example strings and verify they're accepted by both the original DFA and your derived RE!


************************
6. Interactive MCQs
************************

Test your understanding with these multiple-choice questions. Click an option to see immediate feedback!

.. raw:: html

   <div class="mcq-container">
     <p class="mcq-question"><strong>Question 1:</strong> Which regular expression defines the language of strings over :math:`\Sigma = \{a, b\}` that contain at least one 'a'?</p>
     <div class="mcq-options">
       <!-- Option 1 -->
       <div class="mcq-option">
         <input type="radio" id="q1-opt1" name="q1" class="mcq-radio">
         <label for="q1-opt1"><code>b*a*</code></label>
         <div class="mcq-feedback incorrect">
           <p><strong>Incorrect.</strong> This expression can generate the string "b", which has no 'a'. The star operator means zero or more.</p>
         </div>
       </div>
       <!-- Option 2 -->
       <div class="mcq-option">
         <input type="radio" id="q1-opt2" name="q1" class="mcq-radio">
         <label for="q1-opt2"><code>(a+b)*a(a+b)*</code></label>
         <div class="mcq-feedback correct">
           <p><strong>Correct!</strong> This pattern ensures there is at least one 'a' somewhere in the string, with any combination of 'a's and 'b's before and after it.</p>
         </div>
       </div>
       <!-- Option 3 -->
       <div class="mcq-option">
         <input type="radio" id="q1-opt3" name="q1" class="mcq-radio">
         <label for="q1-opt3"><code>a+b*</code></label>
         <div class="mcq-feedback incorrect">
           <p><strong>Incorrect.</strong> This expression matches either exactly one 'a' or any number of 'b's. It doesn't correctly represent all strings with at least one 'a'.</p>
         </div>
       </div>
     </div>
   </div>

   <div class="mcq-container">
     <p class="mcq-question"><strong>Question 2:</strong> The regular expression :math:`(0+1)^*00` describes what set of strings?</p>
     <div class="mcq-options">
       <!-- Option 1 -->
       <div class="mcq-option">
         <input type="radio" id="q2-opt1" name="q2" class="mcq-radio">
         <label for="q2-opt1">All strings starting with '00'.</label>
         <div class="mcq-feedback incorrect">
           <p><strong>Incorrect.</strong> The prefix :math:`(0+1)^*` allows any characters, including '1', to appear before '00'. For example, "1100" is in this language.</p>
         </div>
       </div>
       <!-- Option 2 -->
       <div class="mcq-option">
         <input type="radio" id="q2-opt2" name="q2" class="mcq-radio">
         <label for="q2-opt2">All strings ending with '00'.</label>
         <div class="mcq-feedback correct">
           <p><strong>Correct!</strong> The expression :math:`(0+1)^*` matches any sequence of 0s and 1s, and the expression as a whole requires that sequence to be followed by '00'.</p>
         </div>
       </div>
       <!-- Option 3 -->
       <div class="mcq-option">
         <input type="radio" id="q2-opt3" name="q2" class="mcq-radio">
         <label for="q2-opt3">All strings containing exactly two '0's.</label>
         <div class="mcq-feedback incorrect">
           <p><strong>Incorrect.</strong> The string "000" is in this language, but it has three '0's.</p>
         </div>
       </div>
     </div>
   </div>


***************************
7. Summary & Key Takeaways
***************************

Here's a quick recap of the operators:

.. list-table:: Regular Expression Operators
   :header-rows: 1
   :widths: 15 15 40 30

   * - **Operator**
     - **Symbol**
     - **Meaning**
     - **Example**
   * - Union
     - :math:`+`
     - OR logic (matches one of the options)
     - :math:`a+b` (matches 'a' or 'b')
   * - Concatenation
     - :math:`\cdot` (often omitted)
     - AND THEN logic (matches in sequence)
     - :math:`ab` (matches 'a' followed by 'b')
   * - Kleene Star
     - :math:`*`
     - Zero or more occurrences
     - :math:`a^*` (matches :math:`\epsilon`, 'a', 'aa', ...)

.. note:: ðŸš€ Next Steps
   :class: note

   Great job! You now understand the fundamentals of Regular Expressions. The next logical step is to explore the powerful connection between REs and Finite Automata (FA). You'll learn how to:

   1. Convert any Regular Expression into an NFA.
   2. Convert any DFA into a Regular Expression.

   This equivalence is a cornerstone of the Theory of Computation!
